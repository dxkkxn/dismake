#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:t todo:t |:t
#+TITLE: CAHIER_DE_LABORATOIRE
#+DATE: <2023-11-12 mar.>
#+AUTHOR: Youssef BENJELLOUN EL KBIBI
#+EMAIL: 
#+LANGUAGE: fr
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 25.2.2 (Org mode 9.1.14)

* Gestion du code
** URL du gitlab de l'équipe
https://gitlab.ensimag.fr/benjelly/distrib-make
* Déploiement dans Grid 5000
Modifiez le nom d'utilisateur et ajoutez le path de votre clef ssh
#+BEGIN_SRC bash
    ./copy_connect_g5k.sh # copie les dossier scipts dans un site donné
    ssh $SITE # loggez vous sur le site specifié sur le script précedent
    ./setup.sh
    ./alloc.sh
    cd makefiles
    make YourTest  # (premier, matrix ou blender)
#+END_SRC

* Expérimentations
* Fabrication des courbes de performances
Les courbes de performances sont tracées en utilisant la bibliothèque matplotlib de python. On lance le serveur go et puis on lance le client qui fera des ping-pong, et écrit sur la sortie standard les temps d'aller-retour mesurés, le débit calculé, la taille des message envoyés... Le programme metrics.py lit cette sortie et la parse afin de tirer les différentes données, et puis génère 3 graphiques différents : Le temps d'aller-retour en fonction de la taille des messages, le débit en fonction de la taille, et un histogramme représentant la distribution des temps d'aller-retour. Pour lancer ces mesure il suffit donc de lancer la commande : 
#+BEGIN_SRC sh
go run client/main.go 2>&1 | python3 metrics.py
#+END_SRC
